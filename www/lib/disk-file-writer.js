/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
define("disk-file-writer", [], () => { return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/db.ts":
/*!*******************!*\
  !*** ./src/db.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((global) => {\n    class DB {\n        constructor(dbName, version) {\n            this.db = null;\n            this.storeName = 'fileHandle';\n            this.objectStore = null;\n            this.mainRequest = null;\n            this.dbName = dbName;\n            this.version = version || 0;\n            this.keyPath = 'id';\n            this.init();\n        }\n        init() {\n            if (!this.dbName) {\n                throw new Error('db name not provided');\n            }\n            this.mainRequest = global.indexedDB.open(this.dbName, this.version);\n            this.mainRequest.onsuccess = (e) => {\n                // @ts-ignore\n                this.db = e.target.result;\n                console.log('db open success');\n                this.onOpenSuccessCallback();\n            };\n            this.mainRequest.onerror = () => {\n                console.log('db open failed');\n            };\n            this.mainRequest.onupgradeneeded = e => {\n                console.log(\"onupgradeneeded\");\n                // @ts-ignore\n                this.db = e.target.result;\n                if (!this.db.objectStoreNames.contains(this.storeName)) {\n                    const objectStore = this.db.createObjectStore(this.storeName, {\n                        keyPath: this.keyPath,\n                        autoIncrement: true\n                    });\n                    objectStore.createIndex('type', 'type', { unique: false });\n                }\n            };\n        }\n        addData(data, keyName, type) {\n            const request = this.db.transaction([this.storeName], 'readwrite')\n                .objectStore(this.storeName)\n                .add({ id: keyName, data, type });\n            request.onsuccess = () => console.log('add data success');\n            request.onerror = (e) => console.log('add data failed', e);\n        }\n        putData(data, keyName, type) {\n            const request = this.db.transaction([this.storeName], 'readwrite')\n                .objectStore(this.storeName)\n                .put({ id: keyName, data, type });\n            request.onsuccess = () => console.log('put data success');\n            request.onerror = (e) => console.log('put data failed', e);\n        }\n        async getData(keyName) {\n            return new Promise((res, rej) => {\n                const request = this.db.transaction([this.storeName], 'readwrite')\n                    .objectStore(this.storeName)\n                    .get(keyName);\n                request.onsuccess = (e) => {\n                    console.log('getData ' + keyName + ' success');\n                    // @ts-ignore\n                    return res(e.target.result);\n                };\n                request.onerror = (e) => {\n                    console.log('getData ' + keyName + ' failed');\n                    return rej(e);\n                };\n            });\n        }\n        delete(keyName) {\n            const request = this.db.transaction([this.storeName], 'readwrite')\n                .objectStore(this.storeName)\n                .delete(keyName);\n            request.onsuccess = () => console.log('delete ' + keyName + ' data success');\n            request.onerror = (e) => console.log('delete ' + keyName + ' data failed', e);\n        }\n        async getAllData(type) {\n            return new Promise((res, rej) => {\n                const store = this.db.transaction([this.storeName], 'readwrite')\n                    .objectStore(this.storeName);\n                if (store.indexNames.contains('type')) {\n                    const request = store.index('type')\n                        .openCursor(IDBKeyRange.only(type));\n                    const result = [];\n                    request.onsuccess = (e) => {\n                        console.log('getAllData of type: ' + type + ' success');\n                        // @ts-ignore\n                        const cursor = e.target.result;\n                        if (cursor && cursor.value) {\n                            result.push(cursor.value);\n                            cursor.continue();\n                        }\n                        else {\n                            res(result);\n                        }\n                    };\n                    request.onerror = (e) => {\n                        console.log('getData ' + type + ' failed');\n                        return rej(e);\n                    };\n                }\n                else {\n                    res([]);\n                }\n            });\n        }\n        close() {\n            this.db.close();\n            console.log('database closed');\n        }\n        onOpenSuccessCallback() {\n            console.log('the open success callback has not be implemented');\n        }\n    }\n    global.DB = DB;\n    return global.DB;\n});\n\n\n//# sourceURL=webpack://disk-file-writer/./src/db.ts?");

/***/ }),

/***/ "./src/file-worker.ts":
/*!****************************!*\
  !*** ./src/file-worker.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./db */ \"./src/db.ts\");\n\n// trick typescript\nconst DB = (0,_db__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (() => {\n    const subDirNameOfLog = 'zoomlogs';\n    const getDate = (time) => {\n        const _date = time ? new Date(time) : new Date();\n        const date = _date.toISOString().split('T')[0];\n        return date;\n    };\n    const indexDBKey = {\n        rootDir: btoa('rootDir'),\n        realtimeLogFileHandle: btoa('realtimeLogFileHandle'),\n        latestNormalLogFileChunkNumber: btoa('latestNormalLogFileChunkNumber'),\n        dateOfToday: btoa('dateOfToday'),\n    };\n    const db = new DB('fileHandle', 1);\n    const getTimeStamp = () => {\n        return '[' + new Date().toLocaleString() + '] ';\n    };\n    const encoder = new TextEncoder();\n    const fileType2Return = 'fileType2Return';\n    const globalParams = {\n        directoryHandle: undefined,\n        fileSizeQuota: undefined,\n        filenamePrefix: undefined,\n        filenameExtension: undefined,\n        dbKeyForCurrentFileHandle: undefined,\n        textFileHandle: undefined,\n        textFileLatestDate: undefined,\n        syncAccessHandle: undefined,\n        isSyncAccessHandleLocked: false,\n        isRealTimeLogFileBusy: false,\n        intervalHandle: undefined,\n        mediaRecorder: undefined,\n        maxDaysToKeepFile: 0,\n        textFileAccessHandle: undefined,\n        isTextFileAccessHandleBusy: false,\n        moveToDestDirStrategy: 'none',\n        allFileHandlersObj: {},\n        textsTempForNormalFile: null,\n        textsTempForRealTimeFile: null,\n        tempLogFileHandle: undefined\n    };\n    const saveFile = async () => {\n        console.log('saveFile');\n        const textFileAccessHandle = globalParams.textFileAccessHandle;\n        globalParams.textFileAccessHandle = null;\n        await textFileAccessHandle.flush();\n        await textFileAccessHandle.close();\n    };\n    const getFileHandle = async () => {\n        var _a;\n        const fileFromDB = await db.getData(globalParams.dbKeyForCurrentFileHandle);\n        const fileHandle = fileFromDB && fileFromDB.data;\n        const dateOfTodayFromIDB = (_a = (await db.getData(indexDBKey.dateOfToday))) === null || _a === void 0 ? void 0 : _a.data;\n        if (!fileHandle) {\n            return createNewFileHandle();\n        }\n        else if (dateOfTodayFromIDB !== getDate()) {\n            // a new day;\n            rotateLogFile();\n            return createNewFileHandle();\n        }\n        try {\n            const file = await fileHandle.getFile();\n            console.log('get fileHandle from db', file);\n        }\n        catch (error) {\n            console.log('getFile failed:', error);\n            return createNewFileHandle();\n        }\n        return fileHandle;\n    };\n    async function verifyPermission(fileHandle, readWrite) {\n        const options = {\n            mode: 'read'\n        };\n        if (readWrite) {\n            options.mode = 'readwrite';\n        }\n        // Check if permission was already granted. If so, return true.\n        if ((await fileHandle.queryPermission(options)) === 'granted') {\n            return true;\n        }\n        // Request permission. If the user grants permission, return true.\n        if ((await fileHandle.requestPermission(options)) === 'granted') {\n            return true;\n        }\n        // The user didn't grant permission, so return false.\n        return false;\n    }\n    const createNewFileHandle = async () => {\n        var _a, _b;\n        const { filenamePrefix, filenameExtension } = globalParams;\n        const dateOfToday = getDate();\n        const dateOfTodayFromIDB = ((_a = (await db.getData(indexDBKey.dateOfToday))) === null || _a === void 0 ? void 0 : _a.data) || dateOfToday;\n        if (dateOfTodayFromIDB !== getDate()) {\n            // means today is a new day\n            db.putData(0, indexDBKey.latestNormalLogFileChunkNumber);\n        }\n        const latestNormalLogFileChunkNumber = ((_b = (await db.getData(indexDBKey.latestNormalLogFileChunkNumber))) === null || _b === void 0 ? void 0 : _b.data) || 0;\n        const newLatestNormalLogFileChunkNumber = latestNormalLogFileChunkNumber + 1;\n        globalParams.textFileLatestDate = +new Date();\n        const fileNameWithDate = `${filenamePrefix}_${dateOfToday}_${newLatestNormalLogFileChunkNumber}${filenameExtension}`;\n        const _textFileHandle = await globalParams.directoryHandle.getFileHandle(fileNameWithDate, { create: true });\n        db.putData(_textFileHandle, globalParams.dbKeyForCurrentFileHandle);\n        db.putData(newLatestNormalLogFileChunkNumber, indexDBKey.latestNormalLogFileChunkNumber);\n        db.putData(dateOfToday, indexDBKey.dateOfToday);\n        return _textFileHandle;\n    };\n    async function* getFilesHandleRecursively(entry) {\n        if (entry.kind === 'file') {\n            yield entry;\n        }\n        else if (entry.kind === 'directory') {\n            for await (const handle of entry.values()) {\n                yield* getFilesHandleRecursively(handle);\n            }\n        }\n    }\n    const removeFile = async (fileHandle, directoryHandle) => {\n        const permission = await verifyPermission(fileHandle, true);\n        if (permission) {\n            if (fileHandle.remove) {\n                // The FileSystemHandle.remove() method is currently behind a flag.\n                fileHandle.remove();\n            }\n            else {\n                directoryHandle.removeEntry(fileHandle.name);\n            }\n        }\n    };\n    const rotateLogFile = async () => {\n        const beforeMaxDays = globalParams.textFileLatestDate - globalParams.maxDaysToKeepFile * 86400000; // 24 * 3600 * 1000\n        const rootDirHandle = await navigator.storage.getDirectory();\n        for await (const fileHandle of getFilesHandleRecursively(rootDirHandle)) {\n            const lastModified = (await fileHandle.getFile()).lastModified;\n            if (lastModified < beforeMaxDays) {\n                removeFile(fileHandle, rootDirHandle);\n            }\n        }\n    };\n    const moveOPFSFileByDate = async ({ startDate, endDate, includeUnfinishedFiles, targetDirHandle }) => {\n        const rootDirHandle = await navigator.storage.getDirectory();\n        for await (const fileHandle of getFilesHandleRecursively(rootDirHandle)) {\n            console.log(fileHandle, 'fileHandle');\n            if (globalParams.tempLogFileHandle && await fileHandle.isSameEntry(globalParams.tempLogFileHandle)) {\n                continue;\n            }\n            const lastModified = (await fileHandle.getFile()).lastModified;\n            if ((!startDate || lastModified > startDate) && (!endDate || lastModified < endDate)) {\n                if (includeUnfinishedFiles || !(globalParams.textFileHandle && await fileHandle.isSameEntry(globalParams.textFileHandle))) {\n                    fileHandle.move(targetDirHandle);\n                    globalParams.textFileHandle = null;\n                }\n                else {\n                    console.warn(\"current file can't be moved because it's not complete\");\n                }\n            }\n        }\n    };\n    const mergeArrayBuffers = (arrayBuffers) => {\n        return arrayBuffers.reduce((buffer1, buffer2) => {\n            if (!buffer1) {\n                return buffer2;\n            }\n            else if (!buffer2) {\n                return buffer1;\n            }\n            var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n            tmp.set(new Uint8Array(buffer1), 0);\n            tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n            return tmp;\n        });\n    };\n    const handleLog = async (text) => {\n        let writeBuffer;\n        if (typeof text !== 'string') {\n            if ((text === null || text === void 0 ? void 0 : text.byteLength) !== undefined) {\n                writeBuffer = mergeArrayBuffers([encoder.encode(getTimeStamp()), text.buffer, encoder.encode('\\n')]);\n            }\n        }\n        else {\n            writeBuffer = encoder.encode(getTimeStamp() + text + '\\n');\n        }\n        if (!(globalParams.textFileAccessHandle || globalParams.syncAccessHandle)) {\n            globalParams.textsTempForNormalFile = mergeArrayBuffers([globalParams.textsTempForNormalFile, writeBuffer]);\n            console.log(text, 'text');\n            console.warn('no files to write, save log to temp');\n            return;\n        }\n        if (globalParams.syncAccessHandle) {\n            globalParams.textsTempForRealTimeFile = mergeArrayBuffers([globalParams.textsTempForRealTimeFile, writeBuffer]);\n            if (globalParams.isRealTimeLogFileBusy || globalParams.isSyncAccessHandleLocked) {\n                return;\n            }\n            globalParams.isRealTimeLogFileBusy = true;\n            const accessHandle = globalParams.syncAccessHandle;\n            const fsize = await accessHandle.getSize();\n            await accessHandle.write(globalParams.textsTempForRealTimeFile, { at: fsize });\n            globalParams.textsTempForRealTimeFile = null;\n            globalParams.isRealTimeLogFileBusy = false;\n        }\n        if (globalParams.textFileAccessHandle) {\n            globalParams.textsTempForNormalFile = mergeArrayBuffers([globalParams.textsTempForNormalFile, writeBuffer]);\n            if (globalParams.isTextFileAccessHandleBusy) {\n                // because self.onmessage can't support async function, so we have to use lock\n                return;\n            }\n            globalParams.isTextFileAccessHandleBusy = true;\n            let fileSize = await globalParams.textFileAccessHandle.getSize();\n            if (fileSize >= globalParams.fileSizeQuota) {\n                await saveFile();\n                if (globalParams.moveToDestDirStrategy === 'after-each-finished') {\n                    const rootDirHandle = globalParams.allFileHandlersObj[indexDBKey.rootDir];\n                    const logDirHandle = await rootDirHandle.getDirectoryHandle(subDirNameOfLog);\n                    globalParams.textFileHandle.move(logDirHandle);\n                }\n                const date = getDate();\n                if (date !== getDate(globalParams.textFileLatestDate)) {\n                    // a new day, we need to rotate logs\n                    rotateLogFile();\n                }\n                const fileHandle = await createNewFileHandle();\n                globalParams.textFileHandle = fileHandle;\n                globalParams.textFileAccessHandle = await fileHandle.createSyncAccessHandle();\n                fileSize = 0;\n            }\n            globalParams.textFileAccessHandle.write(globalParams.textsTempForNormalFile, { at: fileSize });\n            globalParams.textsTempForNormalFile = null;\n            globalParams.isTextFileAccessHandleBusy = false;\n        }\n    };\n    /* eslint-disable */\n    self.onmessage = async (e) => {\n        var _a;\n        switch ((_a = e.data) === null || _a === void 0 ? void 0 : _a.cmd) {\n            case 'initialParams':\n                const channel = new BroadcastChannel(e.data.channelName);\n                channel.onmessage = ({ data }) => {\n                    handleLog(data);\n                };\n                break;\n            case 'startWriteNormalLogFile':\n                const { filenamePrefix, fileSizeQuota, maxDaysToKeepFile, filenameExtension, moveToDestDirStrategy } = e.data;\n                const directoryHandle = globalParams.directoryHandle || await navigator.storage.getDirectory();\n                globalParams.filenameExtension = filenameExtension;\n                globalParams.filenamePrefix = filenamePrefix;\n                globalParams.directoryHandle = directoryHandle;\n                globalParams.fileSizeQuota = fileSizeQuota;\n                globalParams.maxDaysToKeepFile = maxDaysToKeepFile;\n                globalParams.moveToDestDirStrategy = moveToDestDirStrategy;\n                globalParams.dbKeyForCurrentFileHandle = `${filenamePrefix}_currentFileHandle`;\n                const textFileHandle = globalParams.textFileHandle || await getFileHandle();\n                globalParams.textFileAccessHandle = await textFileHandle.createSyncAccessHandle();\n                self.postMessage({\n                    cmd: 'startWriteNormalLogFileReady'\n                });\n                globalParams.textFileHandle = textFileHandle;\n                break;\n            case 'logs':\n                handleLog(e.data.text);\n                break;\n            case 'clearOPFSFiles':\n                {\n                    const directoryHandle = await navigator.storage.getDirectory();\n                    for await (const fileHandle of getFilesHandleRecursively(directoryHandle)) {\n                        removeFile(fileHandle, directoryHandle);\n                    }\n                    break;\n                }\n            case 'getOPFSFilesInfoByDate':\n                {\n                    const startDate = e.data.startDate;\n                    const endDate = e.data.endDate;\n                    const filesInfo = [];\n                    const rootDirHandle = await navigator.storage.getDirectory();\n                    for await (const fileHandle of getFilesHandleRecursively(rootDirHandle)) {\n                        const file = await fileHandle.getFile();\n                        const lastModified = file.lastModified;\n                        if ((!startDate || lastModified > startDate) && (!endDate || lastModified < endDate)) {\n                            filesInfo.push(file);\n                        }\n                    }\n                    self.postMessage({\n                        cmd: 'OPFSFilesInfo',\n                        payload: filesInfo\n                    });\n                    break;\n                }\n            case 'saveLogFile':\n                await saveFile();\n                self.postMessage({\n                    cmd: 'normallogWriterClosed'\n                });\n                if (e.data.moveToDestDirStrategy === 'after-all-finished') {\n                    const rootDirHandle = globalParams.allFileHandlersObj[indexDBKey.rootDir];\n                    const logDirHandle = await rootDirHandle.getDirectoryHandle(subDirNameOfLog);\n                    await moveOPFSFileByDate({\n                        includeUnfinishedFiles: true,\n                        targetDirHandle: logDirHandle\n                    });\n                }\n                break;\n            case 'moveOPFSFileByDate':\n                await moveOPFSFileByDate({\n                    startDate: e.data.startDate,\n                    endDate: e.data.endDate,\n                    includeUnfinishedFiles: e.data.includeUnfinishedFiles,\n                    targetDirHandle: e.data.targetDirHandle\n                });\n                break;\n            case 'moveOPFSFilesByName':\n                {\n                    const filename = e.data.filename;\n                    const targetDirHandle = e.data.targetDirHandle;\n                    const rootDirHandle = await navigator.storage.getDirectory();\n                    const fileHandle = await rootDirHandle.getFileHandle(filename);\n                    if (!(globalParams.textFileHandle && await fileHandle.isSameEntry(globalParams.textFileHandle))) {\n                        fileHandle.move(targetDirHandle);\n                    }\n                    else {\n                        console.warn(\"current file can't be moved because it's not complete\");\n                    }\n                    break;\n                }\n            case 'startWriteRealTimeLogFile':\n                {\n                    const directoryHandle = await navigator.storage.getDirectory();\n                    const tempLogFileHandle = await directoryHandle.getFileHandle('tempLog.txt', { create: true });\n                    const rootDirHandle = globalParams.allFileHandlersObj[indexDBKey.rootDir];\n                    const logDirHandle = await rootDirHandle.getDirectoryHandle(subDirNameOfLog);\n                    const realTimeLogFileHandle = await logDirHandle.getFileHandle(e.data.realTimeLogFileHandleName, { create: true });\n                    const reader = new FileReader();\n                    const inteval2update = e.data.inteval2update;\n                    reader.onload = async (event) => {\n                        reader.abort();\n                        globalParams.isSyncAccessHandleLocked = true;\n                        globalParams.syncAccessHandle && await globalParams.syncAccessHandle.truncate(0);\n                        globalParams.isSyncAccessHandleLocked = false;\n                        const writable = (await realTimeLogFileHandle.createWritable({ keepExistingData: true }));\n                        const targetLogFile = await realTimeLogFileHandle.getFile();\n                        writable.write({ type: \"write\", position: targetLogFile.size, data: event.target.result });\n                        await writable.close();\n                    };\n                    const syncAccessHandle = await tempLogFileHandle.createSyncAccessHandle();\n                    globalParams.intervalHandle = setInterval(async () => {\n                        const tempLogFile = await tempLogFileHandle.getFile();\n                        reader.readAsArrayBuffer(tempLogFile);\n                    }, inteval2update || 1000);\n                    globalParams.syncAccessHandle = syncAccessHandle;\n                    globalParams.tempLogFileHandle = tempLogFileHandle;\n                    self.postMessage({\n                        cmd: 'startWriteRealTimeLogFileReady'\n                    });\n                }\n                break;\n            case 'stopWriteRealTimeLog':\n                self.postMessage({\n                    cmd: 'realtimeLogWriterClosed'\n                });\n                clearInterval(globalParams.intervalHandle);\n                const syncAccessHandle = globalParams.syncAccessHandle;\n                globalParams.syncAccessHandle = null;\n                syncAccessHandle.flush();\n                syncAccessHandle.close();\n                break;\n            case 'saveData2IndexDB':\n                const value = e.data.value;\n                const key = e.data.key;\n                db.putData(value, key, fileType2Return);\n                globalParams.allFileHandlersObj[key] = value;\n                break;\n            case 'setMessagePort':\n                const port = e.ports[0];\n                port.onmessage = async (e) => {\n                    handleLog(e.data);\n                };\n                break;\n            default:\n                break;\n        }\n    };\n    db.onOpenSuccessCallback = async () => {\n        const allFileHandlers = await db.getAllData(fileType2Return);\n        const allFileHandlersObj = {};\n        allFileHandlers.forEach((fileData) => {\n            allFileHandlersObj[fileData.id] = fileData.data;\n        });\n        self.postMessage({\n            cmd: 'initOK',\n            payload: allFileHandlersObj\n        });\n        globalParams.allFileHandlersObj = allFileHandlersObj;\n    };\n});\n\n\n//# sourceURL=webpack://disk-file-writer/./src/file-worker.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CHANNEL_NAME\": () => (/* binding */ CHANNEL_NAME),\n/* harmony export */   \"FileLoggerForWorker\": () => (/* binding */ FileLoggerForWorker),\n/* harmony export */   \"FileWriter\": () => (/* binding */ FileWriter),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"workerBuilder\": () => (/* binding */ workerBuilder)\n/* harmony export */ });\n/* harmony import */ var _file_worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./file-worker */ \"./src/file-worker.ts\");\n/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./db */ \"./src/db.ts\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui */ \"./src/ui.ts\");\n\n\n\nconst indexDBKey = {\n    rootDir: btoa('rootDir'),\n    realtimeLogFileHandle: btoa('realtimeLogFileHandle')\n};\nconst subDirNameOfLog = 'zoomlogs';\nconst subDirNameOfVideo = 'zoomvideos';\nasync function verifyPermission(fileHandle, readWrite) {\n    const options = {\n        mode: 'read'\n    };\n    if (readWrite) {\n        options.mode = 'readwrite';\n    }\n    // Check if permission was already granted. If so, return true.\n    if ((await fileHandle.queryPermission(options)) === 'granted') {\n        return true;\n    }\n    // Request permission. If the user grants permission, return true.\n    if ((await fileHandle.requestPermission(options)) === 'granted') {\n        return true;\n    }\n    // The user didn't grant permission, so return false.\n    return false;\n}\nclass EventCenter {\n    constructor() {\n        this.eventMGR = new Map();\n        this.emitCache = new Map();\n    }\n    on(eventName, callback, shouldTrigger) {\n        const callbacks = this.eventMGR.get(eventName);\n        if (!callbacks) {\n            this.eventMGR.set(eventName, new Set([callback]));\n            return;\n        }\n        callbacks.add(callback);\n        if (shouldTrigger && this.emitCache.has(eventName)) {\n            const thisEventSet = this.emitCache.get(eventName);\n            thisEventSet.forEach(async (payload) => {\n                thisEventSet.delete(payload);\n                if (callback && typeof callback === 'function') {\n                    await callback(payload);\n                }\n            });\n            this.emitCache.delete(eventName);\n        }\n    }\n    off(eventName, callback) {\n        if (!callback) {\n            this.eventMGR.delete(eventName);\n            return;\n        }\n        const callbacks = this.eventMGR.get(eventName);\n        if (!callbacks) {\n            return;\n        }\n        callbacks.delete(callback);\n    }\n    emit(eventName, payload) {\n        const callbacks = this.eventMGR.get(eventName);\n        if (!callbacks) {\n            // no listener, will cache this emit with payload\n            let thisEventSet = this.emitCache.get(eventName);\n            if (!thisEventSet) {\n                thisEventSet = new Set();\n                this.emitCache.set(eventName, thisEventSet);\n            }\n            thisEventSet.add(payload);\n            return;\n        }\n        callbacks.forEach(async (callback) => {\n            if (callback && typeof callback === 'function') {\n                await callback(payload);\n            }\n        });\n    }\n}\nlet mediaRecorder;\nconst CHANNEL_NAME = btoa('disk-file-writer');\nclass FileWriter extends EventCenter {\n    constructor(props) {\n        super();\n        this.props = props;\n        this.init();\n    }\n    init() {\n        this.isWritingNormalLog = false;\n        this.hasPermission = false;\n        this.handle = workerBuilder(_file_worker__WEBPACK_IMPORTED_MODULE_0__[\"default\"], [_db__WEBPACK_IMPORTED_MODULE_1__[\"default\"]]);\n        this.handle.postMessage({\n            cmd: 'initialParams',\n            channelName: CHANNEL_NAME\n        });\n        this.setupListener();\n    }\n    initAudioContext() {\n        if (this.audioContext) {\n            return;\n        }\n        this.audioContext = new AudioContext();\n        this.audioDestinationNode = this.audioContext.createMediaStreamDestination();\n    }\n    setupListener() {\n        this.handle.onmessage = (ev) => {\n            switch (ev.data.cmd) {\n                // @ts-ignore\n                case 'initOK':\n                    this.realTimeLogFileHandle = ev.data.payload[indexDBKey.realtimeLogFileHandle];\n                    this.rootDir = ev.data.payload[indexDBKey.rootDir];\n                // @ts-ignore\n                case 'startWriteRealTimeLogFileReady':\n                case 'OPFSFilesInfo':\n                case 'normallogWriterClosed':\n                case 'realtimeLogWriterClosed':\n                    this.emit(ev.data.cmd, ev.data.payload);\n                    break;\n                default:\n                    break;\n            }\n        };\n    }\n    addAudioSource(source) {\n        this.initAudioContext();\n        let audioSrouceNode;\n        if ('controls' in source) {\n            // HTMLAudioElement\n            audioSrouceNode = this.audioContext.createMediaElementSource(source);\n        }\n        else if (typeof source.getTracks === 'function') {\n            // MediaStream\n            audioSrouceNode = this.audioContext.createMediaStreamSource(source);\n        }\n        audioSrouceNode.connect(this.audioDestinationNode);\n    }\n    async selectLogDirectory(forceReSelect) {\n        let rootDir;\n        if (!forceReSelect && this.rootDir && await verifyPermission(this.rootDir, true)) {\n            rootDir = this.rootDir;\n            this.hasPermission = true;\n        }\n        else {\n            rootDir = await window.showDirectoryPicker({\n                mode: 'readwrite'\n            });\n            this.rootDir = rootDir;\n            this.handle.postMessage({\n                cmd: 'saveData2IndexDB',\n                value: rootDir,\n                key: indexDBKey.rootDir\n            });\n        }\n        await this.createLogAndVideoDirHandle(rootDir);\n    }\n    async createLogAndVideoDirHandle(rootDir) {\n        this.logDirHandle = await rootDir.getDirectoryHandle(subDirNameOfLog, { create: true });\n        this.videoDirHandle = await rootDir.getDirectoryHandle(subDirNameOfVideo, { create: true });\n    }\n    async startWriteVideoFile({ videoStream, shareScreen, recordMicrophone, folderNameKey }) {\n        if (!this.videoDirHandle) {\n            throw new Error(\"please select a video directory\");\n        }\n        this.initAudioContext();\n        let _videoStream = videoStream;\n        let _audioStream = this.audioDestinationNode.stream;\n        // POSIX \"Fully portable filenames\", A–Z a–z 0–9 . _ -\n        const folderName = `${new Date().toISOString().replace('T', ' ')} ${folderNameKey}`.replace(/:/g, '.');\n        const latestVideoDirHandle = await this.videoDirHandle.getDirectoryHandle(folderName, { create: true });\n        const latestVideoFileHandle = await latestVideoDirHandle.getFileHandle('video.webm', { create: true });\n        if (videoStream && typeof videoStream.getTracks !== 'function') {\n            throw new Error('the stream you passed in is not a valid MediaStream');\n        }\n        if (shareScreen) {\n            _videoStream = await navigator.mediaDevices.getDisplayMedia({\n                video: true,\n                audio: true\n            });\n        }\n        if (recordMicrophone) {\n            _audioStream = await navigator.mediaDevices.getUserMedia({\n                audio: {\n                    sampleRate: 44100,\n                    echoCancellation: true,\n                    noiseSuppression: true\n                },\n                video: false\n            });\n        }\n        const allTracks = [..._videoStream.getTracks(), ..._audioStream.getAudioTracks()];\n        const recorderOption = {\n            audioBitsPerSecond: 128000,\n            videoBitsPerSecond: 2500000,\n            mimeType: 'video/webm; codecs=vp9'\n        };\n        const mixedStream = new MediaStream(allTracks);\n        mediaRecorder = new MediaRecorder(mixedStream, recorderOption);\n        const recoderFileWritable = await latestVideoFileHandle.createWritable();\n        const timeSlice = 1000;\n        mediaRecorder.ondataavailable = async (e) => {\n            recoderFileWritable.write(e.data);\n        };\n        mediaRecorder.onstop = () => {\n            recoderFileWritable.close();\n            allTracks.forEach(track => track.stop());\n        };\n        mediaRecorder.start(timeSlice);\n    }\n    pauseWriteVideoFile() {\n        mediaRecorder.pause();\n    }\n    resumeWriteVideoFile() {\n        mediaRecorder.resume();\n    }\n    stopWriteVideoFile() {\n        mediaRecorder.stop();\n    }\n    startWriteNormalLogFile({ filenamePrefix, filenameExtension, moveToDestDirStrategy = 'none' }) {\n        if (this.isWritingNormalLog) {\n            console.warn('current logging has already started');\n            return;\n        }\n        this.isWritingNormalLog = true;\n        if (moveToDestDirStrategy === 'after-each-finished' && !this.logDirHandle) {\n            throw new Error('please select a log directory');\n        }\n        this.handle.postMessage({\n            cmd: 'startWriteNormalLogFile',\n            fileSizeQuota: this.props.fileSizeQuota,\n            maxDaysToKeepFile: this.props.maxDaysToKeepFile,\n            moveToDestDirStrategy,\n            filenamePrefix: filenamePrefix,\n            filenameExtension: filenameExtension\n        });\n    }\n    setMessagePort(port) {\n        this.handle.postMessage({\n            cmd: 'setMessagePort',\n        }, [port]);\n    }\n    createMessagePort() {\n        const channel = new MessageChannel();\n        const { port1, port2 } = channel;\n        this.handle.postMessage({\n            cmd: 'setMessagePort'\n        }, [port2]);\n        return port1;\n    }\n    writeLog(text) {\n        this.handle.postMessage({\n            cmd: 'logs',\n            text\n        });\n    }\n    saveLogFile(moveToDestDirStrategy) {\n        if (moveToDestDirStrategy === 'after-all-finished' && !this.logDirHandle) {\n            throw new Error('please select a log directory');\n        }\n        this.handle.postMessage({\n            moveToDestDirStrategy,\n            cmd: 'saveLogFile'\n        });\n    }\n    getOPFSFilesInfoByDate(startDate, endDate) {\n        this.handle.postMessage({\n            cmd: 'getOPFSFilesInfoByDate',\n            startDate,\n            endDate\n        });\n    }\n    async getOPFSFileInfoByName(filename) {\n        const rootDirHandle = await navigator.storage.getDirectory();\n        const fileHandle = await rootDirHandle.getFileHandle(filename);\n        return await fileHandle.getFile();\n    }\n    async moveOPFSFileByDate({ startDate, endDate, includeUnfinishedFiles }) {\n        const targetDirHandle = await window.showDirectoryPicker({\n            mode: 'readwrite'\n        });\n        this.handle.postMessage({\n            cmd: 'moveOPFSFileByDate',\n            includeUnfinishedFiles,\n            targetDirHandle,\n            startDate,\n            endDate\n        });\n    }\n    async startWriteRealTimeLogFile({ fileName = 'realtimeLog', fileExtension = '.log', inteval2update = 1000, }) {\n        if (!this.logDirHandle) {\n            throw new Error('please select a log directory');\n        }\n        this.handle.postMessage({\n            cmd: 'startWriteRealTimeLogFile',\n            realTimeLogFileHandleName: fileName + fileExtension,\n            inteval2update,\n        });\n    }\n    stopWriteRealTimeLog() {\n        this.handle.postMessage({\n            cmd: 'stopWriteRealTimeLog'\n        });\n    }\n    clearOPFSFiles() {\n        this.handle.postMessage({\n            cmd: 'clearOPFSFiles'\n        });\n    }\n    destroy() {\n        this.handle.terminate();\n        this.audioContext.close();\n        this.audioDestinationNode.disconnect();\n    }\n}\nconst FileLogger = {\n    channel: null,\n    fileWriter: null,\n    channelName: CHANNEL_NAME,\n    log(str) {\n        if (!this.channel) {\n            this.channel = new BroadcastChannel(this.channelName);\n        }\n        this.channel.postMessage(str);\n    },\n    getWriter() {\n        if (!this.fileWriter) {\n            this.fileWriter = new FileWriter({\n                maxDaysToKeepFile: 30,\n                fileSizeQuota: 1024 * 10 // 10MB for each log file\n            });\n        }\n        return new Promise(resolve => {\n            this.fileWriter.on('initOK', () => {\n                resolve(this.fileWriter);\n            });\n        });\n    },\n    createUI() {\n        this.getWriter().then((fileWriter) => {\n            const ui = new _ui__WEBPACK_IMPORTED_MODULE_2__[\"default\"](fileWriter);\n            ui.init();\n        });\n    }\n};\nconst FileLoggerForWorker = (global) => {\n    const CHANNEL_NAME = btoa('disk-file-writer');\n    const FileLogger = {\n        // @ts-ignore\n        channel: null,\n        log(str) {\n            if (!this.channel) {\n                this.channel = new BroadcastChannel(CHANNEL_NAME);\n            }\n            this.channel.postMessage(str);\n        }\n    };\n    global.FileLogger = FileLogger;\n    return global.FileLogger;\n};\nfunction workerBuilder(worker, deps) {\n    const depsCode = deps.map(dep => `(${dep.toString()})(self);`).join('');\n    const rawCode = worker.toString();\n    const code = `\n        ${depsCode}\n        (${rawCode})(self);\n    `;\n    const blob = new Blob([code], { type: 'text/javascript' });\n    const workerURL = window.URL.createObjectURL(blob);\n    return new Worker(workerURL);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FileLogger);\n\n\n//# sourceURL=webpack://disk-file-writer/./src/index.ts?");

/***/ }),

/***/ "./src/ui.ts":
/*!*******************!*\
  !*** ./src/ui.ts ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ UI)\n/* harmony export */ });\nconst BUTTON_RADIUS = 15;\nclass UI {\n    constructor(fileWriter) {\n        this.fileWriter = fileWriter;\n        this.isRecordMeeting = false;\n        this.isActionPanelShow = false;\n    }\n    // it's a round button\n    createToggleButton() {\n        let isRecordingMeeting = false;\n        const button = document.createElement('button');\n        const btnStyle = button.style;\n        button.textContent = 'start recording';\n        btnStyle.backgroundColor = '#0000ff5e';\n        btnStyle.color = 'white';\n        btnStyle.height = BUTTON_RADIUS * 2 + 'px';\n        btnStyle.width = 'auto';\n        btnStyle.borderRadius = BUTTON_RADIUS + 'px';\n        btnStyle.border = 'none';\n        btnStyle.cursor = 'pointer';\n        btnStyle.alignSelf = 'flex-start';\n        btnStyle.marginTop = '10px';\n        btnStyle.padding = '1px 6px';\n        const update = () => {\n            isRecordingMeeting = !isRecordingMeeting;\n            button.textContent = isRecordingMeeting ? 'stop recording' : 'start recording';\n        };\n        button.onclick = async () => {\n            if (isRecordingMeeting) {\n                this.fileWriter.stopWriteVideoFile();\n                update();\n                return;\n            }\n            await this.selectLogDir();\n            this.fileWriter.startWriteVideoFile({\n                recordMicrophone: true,\n                shareScreen: true,\n                folderNameKey: 'your personal meeting'\n            }).then(update);\n        };\n        return button;\n    }\n    // it's a round button\n    createButton(text = '', onClick) {\n        const button = document.createElement('button');\n        const btnStyle = button.style;\n        btnStyle.backgroundColor = '#0000ff5e';\n        btnStyle.color = 'white';\n        btnStyle.width = 'auto';\n        btnStyle.height = BUTTON_RADIUS * 2 + 'px';\n        btnStyle.borderRadius = BUTTON_RADIUS + 'px';\n        btnStyle.border = 'none';\n        btnStyle.cursor = 'pointer';\n        btnStyle.margin = '10px 0px';\n        btnStyle.padding = '1px 6px';\n        btnStyle.alignSelf = 'flex-start';\n        button.textContent = text;\n        button.title = '';\n        button.onclick = onClick;\n        return button;\n    }\n    init() {\n        const containerDIV = document.createElement('div');\n        const containerDIVStyle = containerDIV.style;\n        containerDIVStyle.display = 'flex';\n        containerDIVStyle.flexDirection = 'column';\n        containerDIVStyle.position = 'fixed';\n        containerDIVStyle.left = '30px';\n        containerDIVStyle.bottom = '60px';\n        containerDIV.onmouseenter = () => {\n            actionPanelDOM.style.display = 'flex';\n        };\n        containerDIV.onmouseleave = () => {\n            actionPanelDOM.style.display = 'none';\n        };\n        const mainToggleButton = this.createToggleButton();\n        const actionPanelDOM = this.createActionPanel();\n        containerDIV.appendChild(actionPanelDOM);\n        containerDIV.appendChild(mainToggleButton);\n        document.body.appendChild(containerDIV);\n    }\n    async selectLogDir() {\n        await this.fileWriter.selectLogDirectory();\n        this.permissionButton.style.display = 'none';\n    }\n    createActionPanel() {\n        let isRealTimeDebugging = false;\n        const actionPanelDOM = document.createElement('div');\n        const realTimeDebuggingButton = this.createButton('debugging', async () => {\n            const update = () => {\n                isRealTimeDebugging = !isRealTimeDebugging;\n                realTimeDebuggingButton.textContent = isRealTimeDebugging ? 'stop debugging' : 'debugging';\n            };\n            if (isRealTimeDebugging) {\n                this.fileWriter.stopWriteRealTimeLog();\n                update();\n                return;\n            }\n            await this.selectLogDir();\n            this.fileWriter.startWriteRealTimeLogFile({\n                fileName: 'real-time log',\n                fileExtension: '.txt',\n                inteval2update: 1500,\n                maybeReuseExistingFile: true\n            }).then(update);\n        });\n        const permissionButton = this.createButton('request permission', async () => {\n            if (await this.fileWriter.rootDir.requestPermission({ mode: 'readwrite' }) === 'granted') {\n                permissionButton.style.display = 'none';\n                await this.fileWriter.createLogAndVideoDirHandle(this.fileWriter.rootDir);\n                this.fileWriter.startWriteNormalLogFile({\n                    filenamePrefix: 'Media_SDK',\n                    filenameExtension: '.txt',\n                    moveToDestDirStrategy: 'after-each-finished'\n                });\n            }\n        });\n        permissionButton.style.background = 'red';\n        const selectLogDirButton = this.createButton('choose where to store file', async () => {\n            await this.selectLogDir();\n            selectLogDirButton.style.display = 'none';\n            this.fileWriter.startWriteNormalLogFile({\n                filenamePrefix: 'Media_SDK',\n                filenameExtension: '.txt',\n                moveToDestDirStrategy: 'after-each-finished'\n            });\n        });\n        if (!this.fileWriter.rootDir) {\n            permissionButton.style.display = 'none';\n        }\n        else {\n            selectLogDirButton.style.display = 'none';\n            if (this.fileWriter.hasPermission) {\n                permissionButton.style.display = 'none';\n            }\n        }\n        const actionPanelStyle = actionPanelDOM.style;\n        actionPanelStyle.display = 'none';\n        actionPanelStyle.flexDirection = 'column';\n        actionPanelDOM.appendChild(permissionButton);\n        actionPanelDOM.appendChild(selectLogDirButton);\n        actionPanelDOM.appendChild(realTimeDebuggingButton);\n        this.realTimeDebuggingButton = realTimeDebuggingButton;\n        this.permissionButton = permissionButton;\n        this.updateLogActionButton(!!this.fileWriter.logDirHandle);\n        return actionPanelDOM;\n    }\n    updateLogActionButton(isShow) {\n        if (isShow) {\n            this.fileWriter.startWriteNormalLogFile({\n                filenamePrefix: 'Media_SDK',\n                filenameExtension: '.txt',\n                moveToDestDirStrategy: 'after-each-finished'\n            });\n        }\n    }\n}\n\n\n//# sourceURL=webpack://disk-file-writer/./src/ui.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});;